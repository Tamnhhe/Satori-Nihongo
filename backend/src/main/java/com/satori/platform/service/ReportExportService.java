package com.satori.platform.service;

import com.satori.platform.service.dto.ReportDataDTO;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.time.format.DateTimeFormatter;
import java.util.List;

@Service
public class ReportExportService {

    private final Logger log = LoggerFactory.getLogger(ReportExportService.class);

    /**
     * Export report to PDF format
     */
    public byte[] exportToPdf(ReportDataDTO report) {
        log.debug("Exporting report {} to PDF", report.getReportId());

        try {
            // For now, return a placeholder PDF content
            // In a real implementation, you would use libraries like iText or Apache PDFBox
            String pdfContent = generatePdfContent(report);
            return pdfContent.getBytes();
        } catch (Exception e) {
            log.error("Error exporting report to PDF", e);
            throw new RuntimeException("Failed to export report to PDF", e);
        }
    }

    /**
     * Export report to Excel format
     */
    public byte[] exportToExcel(ReportDataDTO report) {
        log.debug("Exporting report {} to Excel", report.getReportId());

        try (Workbook workbook = new XSSFWorkbook();
                ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {

            // Create summary sheet
            Sheet summarySheet = workbook.createSheet("Report Summary");
            createSummarySheet(summarySheet, report);

            // Create sheets for each section
            for (int i = 0; i < report.getSections().size(); i++) {
                ReportDataDTO.ReportSection section = report.getSections().get(i);
                String sheetName = sanitizeSheetName(section.getTitle(), i);
                Sheet sectionSheet = workbook.createSheet(sheetName);
                createSectionSheet(sectionSheet, section);
            }

            workbook.write(outputStream);
            return outputStream.toByteArray();

        } catch (IOException e) {
            log.error("Error exporting report to Excel", e);
            throw new RuntimeException("Failed to export report to Excel", e);
        }
    }

    /**
     * Export report to CSV format
     */
    public byte[] exportToCsv(ReportDataDTO report) {
        log.debug("Exporting report {} to CSV", report.getReportId());

        try {
            StringBuilder csvContent = new StringBuilder();

            // Add report header
            csvContent.append("Report Title,").append(escapeCSV(report.getTitle())).append("\n");
            csvContent.append("Generated At,")
                    .append(report.getGeneratedAt().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME)).append("\n");
            csvContent.append("Generated By,").append(escapeCSV(report.getGeneratedBy())).append("\n");
            csvContent.append("\n");

            // Add data from each section
            for (ReportDataDTO.ReportSection section : report.getSections()) {
                csvContent.append("Section,").append(escapeCSV(section.getTitle())).append("\n");

                if (section.getTables() != null) {
                    for (ReportDataDTO.ReportTable table : section.getTables()) {
                        csvContent.append("Table,").append(escapeCSV(table.getTitle())).append("\n");

                        // Add headers
                        if (table.getHeaders() != null) {
                            csvContent.append(String.join(",", table.getHeaders().stream()
                                    .map(this::escapeCSV).toArray(String[]::new))).append("\n");
                        }

                        // Add rows
                        if (table.getRows() != null) {
                            for (List<Object> row : table.getRows()) {
                                csvContent.append(String.join(",", row.stream()
                                        .map(cell -> escapeCSV(cell != null ? cell.toString() : ""))
                                        .toArray(String[]::new))).append("\n");
                            }
                        }
                        csvContent.append("\n");
                    }
                }
            }

            return csvContent.toString().getBytes();

        } catch (Exception e) {
            log.error("Error exporting report to CSV", e);
            throw new RuntimeException("Failed to export report to CSV", e);
        }
    }

    private void createSummarySheet(Sheet sheet, ReportDataDTO report) {
        // Create header row
        Row headerRow = sheet.createRow(0);
        headerRow.createCell(0).setCellValue("Report Summary");

        // Create report info
        int rowNum = 2;
        createInfoRow(sheet, rowNum++, "Title", report.getTitle());
        createInfoRow(sheet, rowNum++, "Description", report.getDescription());
        createInfoRow(sheet, rowNum++, "Generated At",
                report.getGeneratedAt().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));
        createInfoRow(sheet, rowNum++, "Generated By", report.getGeneratedBy());
        createInfoRow(sheet, rowNum++, "Report Type", report.getReportType().toString());

        if (report.getMetadata() != null) {
            rowNum++;
            createInfoRow(sheet, rowNum++, "Date Range", report.getMetadata().getDateRange());
            createInfoRow(sheet, rowNum++, "Total Records", String.valueOf(report.getMetadata().getTotalRecords()));
        }

        // Auto-size columns
        sheet.autoSizeColumn(0);
        sheet.autoSizeColumn(1);
    }

    private void createSectionSheet(Sheet sheet, ReportDataDTO.ReportSection section) {
        int rowNum = 0;

        // Section title
        Row titleRow = sheet.createRow(rowNum++);
        titleRow.createCell(0).setCellValue(section.getTitle());
        rowNum++;

        // Add tables
        if (section.getTables() != null) {
            for (ReportDataDTO.ReportTable table : section.getTables()) {
                // Table title
                Row tableTitle = sheet.createRow(rowNum++);
                tableTitle.createCell(0).setCellValue(table.getTitle());

                // Headers
                if (table.getHeaders() != null) {
                    Row headerRow = sheet.createRow(rowNum++);
                    for (int i = 0; i < table.getHeaders().size(); i++) {
                        headerRow.createCell(i).setCellValue(table.getHeaders().get(i));
                    }
                }

                // Data rows
                if (table.getRows() != null) {
                    for (List<Object> row : table.getRows()) {
                        Row dataRow = sheet.createRow(rowNum++);
                        for (int i = 0; i < row.size(); i++) {
                            Object cellValue = row.get(i);
                            Cell cell = dataRow.createCell(i);
                            if (cellValue instanceof Number) {
                                cell.setCellValue(((Number) cellValue).doubleValue());
                            } else {
                                cell.setCellValue(cellValue != null ? cellValue.toString() : "");
                            }
                        }
                    }
                }
                rowNum++; // Empty row between tables
            }
        }

        // Auto-size columns
        for (int i = 0; i < 10; i++) { // Assume max 10 columns
            sheet.autoSizeColumn(i);
        }
    }

    private void createInfoRow(Sheet sheet, int rowNum, String label, String value) {
        Row row = sheet.createRow(rowNum);
        row.createCell(0).setCellValue(label);
        row.createCell(1).setCellValue(value != null ? value : "");
    }

    private String sanitizeSheetName(String name, int index) {
        if (name == null) {
            return "Sheet" + (index + 1);
        }

        // Remove invalid characters for Excel sheet names
        String sanitized = name.replaceAll("[\\[\\]\\*\\?/\\\\:]", "");

        // Limit length to 31 characters (Excel limit)
        if (sanitized.length() > 31) {
            sanitized = sanitized.substring(0, 28) + "...";
        }

        return sanitized.isEmpty() ? "Sheet" + (index + 1) : sanitized;
    }

    private String escapeCSV(String value) {
        if (value == null) {
            return "";
        }

        // Escape quotes and wrap in quotes if contains comma, quote, or newline
        if (value.contains(",") || value.contains("\"") || value.contains("\n")) {
            return "\"" + value.replace("\"", "\"\"") + "\"";
        }

        return value;
    }

    private String generatePdfContent(ReportDataDTO report) {
        // This is a placeholder for PDF generation
        // In a real implementation, you would use a PDF library like iText
        StringBuilder content = new StringBuilder();

        content.append("REPORT: ").append(report.getTitle()).append("\n");
        content.append("Generated: ").append(report.getGeneratedAt()).append("\n");
        content.append("By: ").append(report.getGeneratedBy()).append("\n\n");

        if (report.getSections() != null) {
            for (ReportDataDTO.ReportSection section : report.getSections()) {
                content.append("SECTION: ").append(section.getTitle()).append("\n");
                content.append("Type: ").append(section.getType()).append("\n\n");

                if (section.getTables() != null) {
                    for (ReportDataDTO.ReportTable table : section.getTables()) {
                        content.append("TABLE: ").append(table.getTitle()).append("\n");

                        if (table.getHeaders() != null) {
                            content.append(String.join(" | ", table.getHeaders())).append("\n");
                            content.append("-".repeat(50)).append("\n");
                        }

                        if (table.getRows() != null) {
                            for (List<Object> row : table.getRows()) {
                                content.append(row.stream()
                                        .map(cell -> cell != null ? cell.toString() : "")
                                        .reduce((a, b) -> a + " | " + b)
                                        .orElse("")).append("\n");
                            }
                        }
                        content.append("\n");
                    }
                }
            }
        }

        return content.toString();
    }
}